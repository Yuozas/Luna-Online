#include "stdafx.h"
#include "MiniMapDlg.h"
#include "BigMapDlg.h"
#include "Interface/cWindowManager.h"
#include "Interface/cStatic.h"
#include "Interface/cPushupButton.h"
#include "Interface/cScriptManager.h"
#include "Object.h"
#include "Npc.h"
#include "GameResourceManager.h"
#include "WindowIDEnum.h"
#include "Input/UserInput.h"
#include "mhFile.h"

#include "GameIn.h"
//#include "MainBarDialog.h"
#include "ChatManager.h"
#include "PartyIconManager.h"
#include "EventMapInfo.h"
#include "mhMap.h"

#include "cJackpotManager.h"

// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.04
#include "../hseos/Farm/SHFarmManager.h"
// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.04

// desc_hseos_µ•¿Ã∆Æ ¡∏_01
// S µ•¿Ã∆Æ ¡∏ √ﬂ∞° added by hseos 2007.12.03
#include "../hseos/Date/SHDateManager.h"
// E µ•¿Ã∆Æ ¡∏ √ﬂ∞° added by hseos 2007.12.03
#include "cResourceManager.h"

const DWORD IconDescription[] = 
{
	// index, relative x, relative y
	// ¿ÃπÃ¡ˆ¿« 
	 //0,	9,	9,			//eMNMICON_SELF,
	0, 14, 18,
	13,	8,	8,			//eMNMICON_PARTYMEMBER,
	14,	8,	8,			//eMNMICON_FAMILYMEMBER,
	15,	8,	8,			//eMNMICON_NORMALNPC,
	16,	8,	8,			//eMNMICON_LOADINGPOINT,
	//17, 16, 44,			//eMNMICON_CAMERA,
	9, 20, 48,
	18, 11, 11,			//eMNMICON_QUEST1,
	19, 11, 11,			//eMNMICON_QUEST2,
	20,	11, 11,			//eMNMICON_QUEST3,
	// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
	// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
	0,	0, 0,			//eMNMICON_NULL01,
	0,	0, 0,			//eMNMICON_NULL02,
	0,	0, 0,			//eMNMICON_NULL03,
	0,	0, 0,			//eMNMICON_NULL04,
	6,	8, 8,			//eMNMICON_FARM,
	// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
};


extern int g_MapChannelNum[MAX_MAP_NUM];


CMiniMapDlg::CMiniMapDlg()
{
	m_pMapName		= NULL;
	// 080121 LYW --- MiniMapDlg : √§≥ŒøÎ Ω∫≈¬∆Ω √ﬂ∞°.
	m_pChannel		= NULL;
	m_pPosXY		= NULL;
	m_pZoom			= NULL;
	m_CurMode		= eMINIMAPMODE_SMALL;
	m_dwImageRGB	= RGBA_MAKE( 255, 255, 255, 190 );

	// 070430 LYW --- MiniMapDlg : Add button for toggle minimap.
	m_pToggleBtn = NULL ;
	
	m_IconTable.Initialize(64);
	
	//m_DiplayOriginPosOfImage.x = 0;	// ?√å¬π√å√Å√∂?√á ¬æ√Æ¬¥? ¬∫√é¬∫√ê?√å ¬π√å¬¥√è¬∏√ä √É¬¢¬ø¬°¬º¬≠?√á 0,0¬ø¬° √Ç√Ø√à√∑¬¥√Ç¬∞¬°
	//m_DiplayOriginPosOfImage.y = 0;
	
	m_IconPool.Init(100, 10, "MinimapIconPool");

	// πÃ¥œ∏  ªÛºˆ
	{
		/// «•Ω√«“ ≈©±‚
		m_MiniMap.mViewport.x = 159;
		m_MiniMap.mViewport.y = 146;

		/// ¿©µµøÏ ∆≤∏∏≈≠ ¿Ãµø«— »ƒ πÃ¥œ∏ ¿ª «•Ω√«ÿæﬂ«—¥Ÿ.
		m_MiniMap.mTranslation.x = 6;
		m_MiniMap.mTranslation.y = 46;
	}
}


CMiniMapDlg::~CMiniMapDlg()
{	
	/*for(int n=0;n<eMINIMAPMODE_MAX;++n)
	{
		m_MinimapImage[n].image.Release();
		m_MinimapImage[n].ImageHeight = 0;
		m_MinimapImage[n].ImageWidth = 0;
	}*/

	CMiniMapIcon* pIcon;
	m_IconTable.SetPositionHead();
	while(pIcon = m_IconTable.GetData())
		ReleaseMinniMapIcon(pIcon);
	m_IconTable.RemoveAll();

	ReleaseNumImage();
}
/*
void CMiniMapDlg::SetZoomRate(float zoomrate)
{
	m_ZoomRate = zoomrate;

	m_DisplayMinX = m_DiplayOriginPosOfImage.x*m_ZoomRate;
	m_DisplayMinZ = m_DiplayOriginPosOfImage.y*m_ZoomRate;
	m_DisplayMaxX = (m_DiplayOriginPosOfImage.x+m_MiniMap.mViewport.x)*m_ZoomRate;
	m_DisplayMaxZ = (m_DiplayOriginPosOfImage.y+m_MiniMap.mViewport.y)*m_ZoomRate;
}
*/

void CMiniMapDlg::InitMiniMap(MAPTYPE MapNum)
{
	const eGameInInitKind kind	= ( eGameInInitKind )GAMEIN->GetGameInInitKind();
/*
	if(	eGameInInitKind_SuryunEnter		== kind		||
		eGameInInitKind_EventMapEnter	== kind		||
		BOSSMONSTER_MAP					== MapNum	||
		BOSSMONSTER_2NDMAP				== MapNum )
	{
		SetActive( FALSE );
	}
*/
//	TempID = SKILLOBJECT_ID_START;		// ¬Ω¬∫√Ö¬≥?√å ¬π√å¬¥√è¬∏√ä¬ø¬° ¬µ√Æ¬∑√è ¬µ√â¬∏¬Æ ¬æ√∏?¬∏¬¥√è¬±√Æ.
	
	LoadMinimapImageInfo( m_MapNum = MapNum );

	if( m_pMapName )
	{
		//char text[128] = {0, } ;
// 070430 LYW --- MiniMapdlg : Modified chat msg.
		/*
#ifdef TAIWAN_LOCAL	//chat_msg order
		wsprintf( buf, CHATMGR->GetChatMsg(442),gChannelNum+1,GetMapName(MapNum));
#elif defined _HK_LOCAL_	//chat_msg order
		wsprintf( buf, CHATMGR->GetChatMsg(442),gChannelNum+1,GetMapName(MapNum));
#else
		wsprintf( buf, CHATMGR->GetChatMsg(442),GetMapName(MapNum),gChannelNum+1);
#endif
//		m_pMapName->SetStaticText(GetMapName(MapNum));
		*/
		//wsprintf( text, CHATMGR->GetChatMsg(167),GetMapName(MapNum), gChannelNum+1);
		// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
		// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.04
		/*if (g_csFarmManager.GetFarmZoneID(MapNum, NULL))
		{
			wsprintf(text, GetMapName(MapNum));
		}*/
		// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.04

		//m_pMapName->SetStaticText(text);

		m_pMapName->SetStaticText(GetMapName(MapNum)) ;
	}

	//// 080121 LYW --- MiniMapDlg : √§≥ŒøÎ Ω∫≈¬∆Ω √ﬂ∞°.
	//if( m_pChannel )
	//{
	//	char tempBuf[128] = {0, } ;
	//	sprintf(tempBuf, "%d", gChannelNum+1) ;
	//	strcat(tempBuf, RESRCMGR->GetMsg(102)) ;
	//	m_pChannel->SetStaticText(tempBuf) ;
	//}

	SetChannel(gChannelNum);
}

void CMiniMapDlg::SetChannel(int nChannel)
{

	BOOL bDraw = FALSE;
	if(1 < g_MapChannelNum[m_MapNum])
		bDraw = TRUE;

	if( m_pChannel && bDraw)
	{
		char tempBuf[128] = {0, } ;
		sprintf(tempBuf, "%d", nChannel+1) ;
		strcat(tempBuf, RESRCMGR->GetMsg(102)) ;
		m_pChannel->SetStaticText(tempBuf) ;
	}
}


void CMiniMapDlg::InitIconImage()
{
	const SIZE_T size = sizeof( IconDescription ) / ( sizeof( DWORD ) * 3 );

	for( SIZE_T i = 0; i < size; ++i )
	{
		cImage* image = new cImage;

		const DWORD index	= IconDescription[ 3 * i ];
		const DWORD x		= IconDescription[ 3 * i + 1 ];
		const DWORD y		= IconDescription[ 3 * i + 2 ];
		
		SCRIPTMGR->GetImage( index, image, PFT_MINIMAPPATH );

		m_pIconImage[ i ].InitIconImage( image, x, y );
	}

//KES
	//SCRIPTMGR->GetImage( 63, &m_TooltipImage, PFT_HARDPATH );
}

void CMiniMapDlg::Linking()
{
	memset(m_pIconImage,0,sizeof(cImage*)*eMNMICON_MAX);
	InitIconImage();
	m_pMapName	= (cStatic*)GetWindowForID(MNM_MAPNAME);
	// 080121 LYW --- MiniMapDlg : √§≥ŒøÎ Ω∫≈¬∆Ω √ﬂ∞°.
	m_pChannel = (cStatic*)GetWindowForID(MNM_CHANNELNAME) ;
	m_pPosXY	= (cStatic*)GetWindowForID(MNM_POSXY);
	// 070430 LYW --- MiniMapDlg : Add button for toggle minimap.
	m_pToggleBtn = (cButton*)GetWindowForID(MNM_ONOFF) ;
	m_pToggleBtn->SetActive( TRUE ) ;

	m_pZoom		= (cPushupButton*)GetWindowForID( MNM_TOGGLEFULL );

	JPInit();
	InitNumImage();	
}

void CMiniMapDlg::AddMonsterIcon(CObject* pObject)
{
}
void CMiniMapDlg::AddBossMonsterIcon(CObject* pObject)
{
}
void CMiniMapDlg::AddStaticNpcIcon(CObject* pObject)
{
	CNpc* pNpc = (CNpc*)pObject;
	if(pNpc->GetNpcKind() == 30 || pNpc->GetNpcKind() == 31)
	{
		AddIcon(eMNMICON_LOADINGPOINT,pObject);
	}
	else if(pNpc->GetNpcKind() != 30 && pNpc->GetNpcKind() != 31)
	{
		AddIcon(eMNMICON_NORMALNPC,pObject);
	}

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();

	if( dialog )
	{
		dialog->AddStaticNpcIcon( pObject );
	}
}

void CMiniMapDlg::AddPartyMemberIcon(PARTY_MEMBER* pMember)
{
	AddIcon(eMNMICON_PARTYMEMBER,pMember);

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();

	if( dialog )
	{
		dialog->AddPartyMemberIcon( pMember );
	}
}
/*
void CMiniMapDlg::AddQuestIcon( CObject* pTarget, int nKind )
{
	if( nKind == 0 )
		AddIcon(eMNMICON_QUEST_EXCLAMATION, pTarget);
	else
		AddIcon(eMNMICON_QUEST_QUESTION, pTarget);
//---
	if( GAMEIN->GetBigMapDialog() )
		GAMEIN->GetBigMapDialog()->AddQuestIcon( pTarget, nKind );
}
*/
void CMiniMapDlg::AddHeroIcon(CObject* pObject)
{
	m_HeroIcon.Init(&m_pIconImage[eMNMICON_SELF],pObject, eMNMICON_SELF);
	m_HeroIcon.SetCameraImage( &m_pIconImage[eMNMICON_CAMERA] );

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();

	if( dialog )
	{
		dialog->AddHeroIcon( pObject );
	}
}

// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
void CMiniMapDlg::AddFarmIcon(CSHFarm* pFarm)
{
	AddIcon(eMNMICON_FARM, pFarm);

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();

	if( dialog )
	{
		dialog->AddFarmIcon(pFarm);
	}
}
// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31

CMiniMapIcon* CMiniMapDlg::GetEmptyMiniMapIcon(WORD Kind,CObject* pObject)
{
	CMiniMapIcon* pIcon = m_IconPool.Alloc();
	pIcon->Init(&m_pIconImage[Kind],pObject, Kind);
	pIcon->SetMarkImage(&m_pIconImage[eMNMICON_QUEST1],0, 3 );
	//pIcon->SetMarkImage(0, &m_pIconImage[eMNMICON_QUEST1], 3 );
	return pIcon;
}

CMiniMapIcon* CMiniMapDlg::GetEmptyMiniMapIcon(WORD Kind,PARTY_MEMBER* pMember)
{
	CMiniMapIcon* pIcon = m_IconPool.Alloc();
	pIcon->Init(&m_pIconImage[Kind], pMember, Kind);
	return pIcon;
}

// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
CMiniMapIcon* CMiniMapDlg::GetEmptyMiniMapIcon(WORD Kind, CSHFarm* pFarm)
{
	CMiniMapIcon* pIcon = m_IconPool.Alloc();
	pIcon->Init(&m_pIconImage[Kind], pFarm, Kind);
	return pIcon;
}
// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31

void CMiniMapDlg::ReleaseMinniMapIcon(CMiniMapIcon* pIcon)
{
	m_IconPool.Free(pIcon);
}


void CMiniMapDlg::AddIcon(WORD Kind,CObject* pObject)
{
	ASSERT(m_IconTable.GetData(pObject->GetID()) == NULL);
	RemoveIcon(pObject->GetID());
	CMiniMapIcon* pIcon = GetEmptyMiniMapIcon(Kind,pObject);
	m_IconTable.Add(pIcon,pObject->GetID());
}

void CMiniMapDlg::AddIcon(WORD Kind,PARTY_MEMBER* pMember)
{
	ASSERT(m_IconTable.GetData(pMember->dwMemberID) == NULL);
	RemoveIcon(pMember->dwMemberID);
	CMiniMapIcon* pIcon = GetEmptyMiniMapIcon(Kind,pMember);
	m_IconTable.Add(pIcon,pMember->dwMemberID);
}

// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
void CMiniMapDlg::AddIcon(WORD Kind, CSHFarm* pFarm)
{
	ASSERT(m_IconTable.GetData(pFarm->GetID()+FARM_RENDER_OBJ_ID_START) == NULL);
	RemoveIcon(pFarm->GetID()+FARM_RENDER_OBJ_ID_START);
	CMiniMapIcon* pIcon = GetEmptyMiniMapIcon(Kind, pFarm);
	m_IconTable.Add(pIcon, pFarm->GetID()+FARM_RENDER_OBJ_ID_START);
}
// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31

void CMiniMapDlg::RemoveIcon(DWORD ObjectID)
{
	CMiniMapIcon* pIcon = m_IconTable.GetData( ObjectID );

	if( pIcon )
	{
		ReleaseMinniMapIcon(pIcon);
		m_IconTable.Remove(ObjectID);
	}
}

void CMiniMapDlg::Process()
{
	const MINIMAPIMAGE& pMinimap = m_MinimapImage[m_CurMode];
	DWORD iWidth,iHeight;

	if(m_CurMode == eMINIMAPMODE_FULL)
	{
		iWidth = (DWORD)m_MiniMap.mViewport.x;
		iHeight = (DWORD)m_MiniMap.mViewport.y;
	}
	else
	{
		iWidth = pMinimap.size.cx;
		iHeight = pMinimap.size.cy;
	}

	m_HeroIcon.Update(iWidth,iHeight);
	// PartyIcon¬µ¬µ Update√É√ü¬∞¬°
	PICONMGR->Process();
	
	if(m_pPosXY)
	{
		char text[128];
		VECTOR3 heropos = m_HeroIcon.GetPosition();

		sprintf( text, "%4.0f,%4.0f", heropos.x * 0.01f,heropos.z * 0.01f );
		//sprintf(temp,"%s-√É¬§¬≥√é%d %4.0f,%4.0f",GetMapName(m_MapNum),gChannelNum+1,heropos.x*.01f,heropos.z*.01f);
		//¬∏√ä?√å¬∏¬ß¬∞√∫ √Å√Ç√á¬•¬¥√Ç ¬µ√ª¬∑√é√É¬≥¬∏¬Æ.
		m_pPosXY->SetStaticText(text);
	}

	/*if(m_CurMode == eMINIMAPMODE_FULL)
	FitToCenterIcon(NULL);
	else
	FitToCenterIcon(&m_HeroIcon);*/

	CMiniMapIcon* pIcon;
	m_IconTable.SetPositionHead();
	while(pIcon = m_IconTable.GetData())
	{
		pIcon->Update(iWidth,iHeight);
	}

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();

	if( dialog )
	{
		dialog->Process();
	}

	//Jackpot
	//JPProcess();

	// change map image
	{
		cImageRect& rect = m_MiniMap.mRect;

		if( eMINIMAPMODE_FULL == m_CurMode )
		{
			rect.left = 0;
			rect.top = 0;
		}
		else
		{
			const VECTOR2* heroIconPosition = m_HeroIcon.GetScreenPos();

			rect.left = ( LONG )( heroIconPosition->x - m_MiniMap.mViewport.x / 2.0f );
			rect.top = ( LONG )( heroIconPosition->y - m_MiniMap.mViewport.y / 2.0f );
		}

		rect.right = rect.left + ( LONG )m_MiniMap.mViewport.x;
		rect.bottom = rect.top + ( LONG )m_MiniMap.mViewport.y;

		m_MiniMap.mImage.SetImageSrcRect( &rect );
	}
}

//void CMiniMapDlg::FitToCenterIcon(CMiniMapIcon* pIcon)
//{
//	if(pIcon == NULL)
//	{
//		m_DiplayOriginPosOfImage.x = 0;
//		m_DiplayOriginPosOfImage.y = 0;
//		return;
//	}
//	
//	m_DiplayOriginPosOfImage.x = m_HeroIcon.GetScreenPos()->x - (m_MiniMap.mViewport.x*.5f);
//	m_DiplayOriginPosOfImage.y = m_HeroIcon.GetScreenPos()->y - (m_MiniMap.mViewport.y*.5f);
//
//	m_DisplayMinX = m_DiplayOriginPosOfImage.x;
//	m_DisplayMinZ = m_DiplayOriginPosOfImage.y;
//	m_DisplayMaxX = (m_DiplayOriginPosOfImage.x+m_MiniMap.mViewport.x);
//	m_DisplayMaxZ = (m_DiplayOriginPosOfImage.y+m_MiniMap.mViewport.y);
//}

void CMiniMapDlg::LoadMinimapImageInfo(MAPTYPE MapNum)
{
	DIRECTORYMGR->SetLoadMode(eLM_Minimap);

	char buffer[256];
	CMHFile file;

	sprintf( buffer, "Minimap%d.bin", MapNum );
	file.Init( buffer, "rb", MHFILE_FLAG_DONOTCHANGE_DIRECTORY_TOROOT );

	if( ! file.IsInited() )
	{
		DIRECTORYMGR->SetLoadMode(eLM_Root);
		return;
	}
	
	char name[ 256 ];

	{
		file.GetString( buffer );
		sprintf( name, "../image/%s", buffer );

		MINIMAPIMAGE& data = m_MinimapImage[ eMINIMAPMODE_SMALL ];

		data.size.cx = file.GetDword();
		data.size.cy = file.GetDword();
		data.image.LoadSprite( name );
	}
	
	{
		file.GetString( buffer );
		sprintf( name, "../image/%s", buffer );

		MINIMAPIMAGE& data = m_MinimapImage[ eMINIMAPMODE_FULL ];

		data.size.cx = file.GetDword();
		data.size.cy = file.GetDword();
		data.image.LoadSprite( name );
	}
	
	//file.Release();	
	DIRECTORYMGR->SetLoadMode(eLM_Root);

	CBigMapDlg* dialog = GAMEIN->GetBigMapDialog();
	if( dialog )
	{
		dialog->LoadMinimapImageInfo( MapNum );
	}

	/// πÃ¥œ∏  √ ±‚»≠
	{
		if( eMINIMAPMODE_SMALL == m_CurMode )
		{
			const SIZE& size = m_MinimapImage[ eMINIMAPMODE_SMALL ].size;

			m_MiniMap.mScale.x = m_MiniMap.mViewport.x / size.cx;
			m_MiniMap.mScale.y = m_MiniMap.mViewport.y / size.cy;
		}
		else
		{
			m_MiniMap.mScale.x = 1.0f;
			m_MiniMap.mScale.y = 1.0f;
		}

		m_MiniMap.mImage.SetSpriteObject( m_MinimapImage[ m_CurMode ].image.GetSpriteObject() );
		m_MiniMap.mImage.SetImageSrcSize( &m_MiniMap.mViewport );
	}
}

DWORD CMiniMapDlg::ActionEvent( CMouse* mouseInfo )
{
	DWORD we = cDialog::ActionEvent( mouseInfo );

	if( ! m_bActive )
	{
		return we;
	}

	if( we & WE_MOUSEOVER )
	{
		cImageRect& rect = m_MiniMap.mRect;;
		/*rect.left = (LONG)m_DiplayOriginPosOfImage.x;
		rect.top = (LONG)m_DiplayOriginPosOfImage.y;
		rect.right = (LONG)(m_DiplayOriginPosOfImage.x+m_MiniMap.mViewport.x);
		rect.bottom = (LONG)(m_DiplayOriginPosOfImage.y+m_MiniMap.mViewport.y);*/
		
		char text[128] = {0,};
		
		VECTOR2 trans;
		trans.x = GetAbsX() + m_MiniMap.mTranslation.x - rect.left;
		trans.y = GetAbsY() + m_MiniMap.mTranslation.y - rect.top;
		
		CMiniMapIcon* pIcon;
		m_IconTable.SetPositionHead();
		while(pIcon = m_IconTable.GetData())
		{
			int sort = pIcon->GetToolTip(mouseInfo->GetMouseX(),mouseInfo->GetMouseY(),&trans,text);

			if(sort == 1)				// Npc
			{
				SetToolTip( text, RGB_HALF( 255, 255, 0 ) );
			}
			else if(sort == 2)			// Party
			{
				SetToolTip( text, RGB_HALF(185, 241, 69) );
			}
			// desc_hseos_≥Û¿ÂΩ√Ω∫≈€_01
			// S ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
			else if(sort == 3)			// Party
			{
				SetToolTip( text, RGB_HALF( 255, 255, 0 ) );
			}
			// E ≥Û¿ÂΩ√Ω∫≈€ √ﬂ∞° added by hseos 2007.10.31
		}
 
		if( ! strlen( text ) )
		{
			SetToolTip("");
		}
	}

	return we;
}

void CMiniMapDlg::Render()
{
	if( !	m_bActive ||
			m_MiniMap.mImage.IsNull() )
	{
		return;
	}

	cDialog::RenderWindow();
	
	VECTOR2 trans;
	trans.x = GetAbsX() + m_MiniMap.mTranslation.x;
	trans.y = GetAbsY() + m_MiniMap.mTranslation.y;
	
	m_MiniMap.mImage.RenderSprite( &m_MiniMap.mScale, 0, 0, &trans, m_dwImageRGB );

	cImageRect* rect = &m_MiniMap.mRect;

	trans.x -= rect->left;
	trans.y -= rect->top;
	
	m_IconTable.SetPositionHead();
	for( CMiniMapIcon* pIcon; pIcon = m_IconTable.GetData(); )
	{
		pIcon->Render(&trans,rect);
	}

	m_IconTable.SetPositionHead();
	for( CMiniMapIcon* pIcon; pIcon = m_IconTable.GetData(); )
	{
		pIcon->RenderQuestMark(&trans,rect);
	}

	//////////////////////////////////////////////////////////////////////////
	// √Å√ñ?√é¬∞√∏ ¬∂√ß¬ø√¨¬±√¢
	m_HeroIcon.Render(&trans);

	cDialog::RenderComponent();

	//jackpot

	JPRender();

}

void CMiniMapDlg::RefreshMode()
{
	if( m_pZoom )
		m_pZoom->SetPush( GAMEIN->GetBigMapDialog()->IsActive() );
}

void CMiniMapDlg::ToggleMinimapMode()
{
	if( GAMEIN->GetBigMapDialog() )
	{
		GAMEIN->GetBigMapDialog()->SetActive( !GAMEIN->GetBigMapDialog()->IsActive() );
	}

	RefreshMode();	

/*
	if(m_CurMode == eMINIMAPMODE_FULL)
		m_CurMode = eMINIMAPMODE_SMALL;
	else
		m_CurMode = eMINIMAPMODE_FULL;
*/
}

void CMiniMapDlg::SetActive( BOOL val )
{
	if( CanActive() == FALSE )
		val = FALSE;
	
	cDialog::SetActive( val );

//--- main bar icon
//	CMainBarDialog* pDlg = GAMEIN->GetMainInterfaceDialog();
//	if( pDlg )
//		pDlg->SetPushBarIcon( OPT_MINIMAPDLGICON, m_bActive );
}


void CMiniMapDlg::SetPartyIconTargetPos(DWORD PlayerID, int posX, int posZ)
{
	CMiniMapIcon* pIcon = m_IconTable.GetData(PlayerID);
	if(pIcon)
		pIcon->SetTargetPos(posX, posZ);

//---
	if( GAMEIN->GetBigMapDialog() )
		GAMEIN->GetBigMapDialog()->SetPartyIconTargetPos( PlayerID, posX, posZ );
}

void CMiniMapDlg::SetPartyIconObjectPos(DWORD PlayerID, int posX, int posZ)
{
	CMiniMapIcon* pIcon = m_IconTable.GetData(PlayerID);
	if(pIcon)
	{
		pIcon->SetObjectPos(posX, posZ);
		pIcon->SetTargetPos(posX, posZ);
	}

//---
	if( GAMEIN->GetBigMapDialog() )
		GAMEIN->GetBigMapDialog()->SetPartyIconObjectPos( PlayerID, posX, posZ );
}

BOOL CMiniMapDlg::CanActive()
{
	/*
	switch( MAP->GetMapNum() )
	{
	case BOSSMONSTER_MAP:		// bossmap
	case BOSSMONSTER_2NDMAP:	// 2nd bossmap
	case Tournament:			// ≈‰≥ ∏’∆Æ
	case QuestRoom:				// ±‚ø¨¿«πÊ
	case dongkyung:				// ¿Ã∫•∆Æ∏ 
	case jangbeak:				// ¿Ã∫•∆Æ∏ 
		return FALSE;
		break;
	}
	*/

	// desc_hseos_µ•¿Ã∆Æ ¡∏_01
	// S µ•¿Ã∆Æ ¡∏ √ﬂ∞° added by hseos 2007.12.03
	// ..√ß∏∞¡ˆ ¡∏ø°¥¬ πÃ¥œ∏ ¿Ã æ¯¥Ÿ.
	if (g_csDateManager.IsChallengeZone(MAP->GetMapNum()))
	{
		return FALSE;
	}
	// E µ•¿Ã∆Æ ¡∏ √ﬂ∞° added by hseos 2007.12.03

	return TRUE;
}

void CMiniMapDlg::ShowQuestMarkIcon( CObject* pTarget, int nKind )
{
	CMiniMapIcon* pIcon = m_IconTable.GetData( pTarget->GetID() );
	if( pIcon == NULL ) return;

	pIcon->ShowQuestMark( nKind );

//---
	if( GAMEIN->GetBigMapDialog() )
		GAMEIN->GetBigMapDialog()->ShowQuestMarkIcon( pTarget, nKind );
}


//SW050722 jackpot_number
LONG NumImgRelpos[] =
{
	135, 191,
	119, 191,
	103, 191,
	87, 191,
	71, 191,
	55, 191,
	39, 191,
	23, 191,
	7, 191,
};

void CMiniMapDlg::InitNumImage()
{
	cImage* pImg;
	for( int n = 0; n < IMAGE_COUNT; ++n )
	{
		pImg = new cImage;
		SCRIPTMGR->GetImage(n, pImg, PFT_JACKPOTPATH);
		m_stNumImage[n].pImage = pImg;
//		m_stNumImage[n].dwW = NUMIMAGE_W;
//		m_stNumImage[n].dwH = NUMIMAGE_H;
	}
}

void CMiniMapDlg::ReleaseNumImage()
{
	for( int n = 0; n < IMAGE_COUNT; ++n )
	{
		if(m_stNumImage[n].pImage)
		{
			delete m_stNumImage[n].pImage;
			m_stNumImage[n].pImage = NULL;
		}
	}
}

void CMiniMapDlg::SetNumImagePos()
{
	float fDialPosX = this->GetAbsX();
	float fDialPosY = this->GetAbsY();

	for( int i = 0; i < CIPHER_NUM; ++i )
	{
		m_vPos[i].x = fDialPosX + (float)NumImgRelpos[i*2];
		m_vPos[i].y = fDialPosY + (float)NumImgRelpos[i*2+1];
	}

	//SW050805 ¿⁄∏Æºˆ ±∏∫–¡° √ﬂ∞°
	m_vDotPos[0].x = fDialPosX + 98;
	m_vDotPos[0].y = fDialPosY + 205;
	m_vDotPos[1].x = fDialPosX + 50;
	m_vDotPos[1].y = fDialPosY + 205;
}

void CMiniMapDlg::ConvertCipherNum()
{// ∞¢¿⁄∏Æ º˝¿⁄∏¶ ±∏«—¥Ÿ. Get Number per Each Cipher
	// º˝¿⁄ ∫Ø»≠Ω√ ∞ªΩ≈ æ÷¥œ∏¶ «—¥Ÿ. Do Animations When Number Changers
/*
	int n = 0;	// n¿⁄∏Æºˆ
	DWORD d = 1;	// ¥‹¿ß

	DWORD money = m_dwTotalMoney;

	if( !money ) return;
	while( money / d > 0 )
	{//	¿⁄∏Æºˆ ±∏«œ±‚ n
		d *= 10;
		n++;
	}

	ASSERT(n<CIPHER_NUM);
	d /= 10;

	m_dwMaxCipher = n;	// Need in ChangingAni

	for( int i = 1; i <= n; ++i )
	{// ≈´¿⁄∏Æ ∫Œ≈Õ
		m_stCipherNum[n-i].dwNumber = money / d;
		m_stCipherNum[n-i].bIsAni = TRUE;
		money = m_dwTotalMoney % d;
		d /= 10;
	}
*/
	int n = 1;	// n¿⁄∏Æºˆ 0 µµ 1¿⁄∏Æ∑Œ ∫ª¥Ÿ. ±◊∏Æ±‚¿ß«ÿ!
	DWORD d = 10;
	while( m_dwTotalMoney / d > 0 )
	{
		d *= 10;
		n++;
	}
	
	m_dwMaxCipher = n;

	DWORD dec = 10;
	DWORD tmp = m_dwTotalMoney;

	for( int i = 0; i < n; ++i )
	{
		m_stCipherNum[i].dwNumber = tmp % dec;
		m_stCipherNum[i].bIsAni = TRUE;
		tmp /= dec;
	}

	while( n < CIPHER_NUM )
	{
		m_stCipherNum[n].dwNumber = DEFAULT_IMAGE;
		m_stCipherNum[n].bIsAni = FALSE;
		++n;
	}
}

bool CMiniMapDlg::IsNumChanged()					// º˝¿⁄ ∫Ø»≠ √º≈©	// Check Num charnges
{
	if( m_dwOldTotalMoney != m_dwTotalMoney )
	{
		if( m_dwTotalMoney < m_dwOldTotalMoney || m_dwOldTotalMoney == 0 )	// µ∑ ¡Ÿ∞≈≥™ ∏ √≥¿Ω ¡¢º”¿Ã∏È..
		{
			m_bDoSequenceAni = FALSE;
		}
		else
		{
			m_bDoSequenceAni = TRUE;
		}
		
		m_dwTempMoney		= m_dwOldTotalMoney;	// For SequenceAni
		m_dwOldTotalMoney	= m_dwTotalMoney;	// For CompareChanges
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

void CMiniMapDlg::DoAni()				// º˝¿⁄ ∫Ø»Ø æ÷¥œ	// Ticktime control
{
	if( ! m_bIsAnimationing )
	{
		return;
	}

	if( gCurTime - m_dwNumChangeTime > NUM_CHANGE_TIMELENGTH )
	{
		for( int i = 0; i < CIPHER_NUM; ++i )
		{
			if( m_stCipherNum[i].bIsAni )
			{
				++m_stCipherNum[i].dwNumber;

				if(m_stCipherNum[i].dwNumber > 9)
				{
					m_stCipherNum[i].dwNumber = 0;
				}
			}
		}

//		m_dwNumChangeTime = curtime;
	}

	if( gCurTime - m_dwAniStartTime >= BASIC_ANI_TIMELENGTH	&&
		gCurTime - m_dwIntervalAniTime > BETWEEN_ANI_TIMELENGTH )
	{
		if(m_stCipherNum[m_dwCipherCount].bIsAni)
		{
			m_stCipherNum[m_dwCipherCount].dwNumber = m_stCipherNum[m_dwCipherCount].dwRealCipherNum;
			m_stCipherNum[m_dwCipherCount].bIsAni = FALSE;
		}

		if(m_dwCipherCount == m_dwMaxCipher)
		{
			m_bIsAnimationing = FALSE;
			return;
		}

		m_dwIntervalAniTime = gCurTime;
		++m_dwCipherCount;
	}
}

void CMiniMapDlg::DoSequenceAni()
{
	if( m_bIsAnimationing )
	{
		DWORD EllipsedTime	=  gCurTime - m_dwAniStartTime;
		DWORD durMoney		=  EllipsedTime * 33;
		m_dwTotalMoney		= m_dwTempMoney + durMoney;

		if( m_dwTotalMoney >= m_dwOldTotalMoney )
		{
			m_dwTotalMoney = m_dwOldTotalMoney;
			m_bIsAnimationing = FALSE;
		}
	}
}

void CMiniMapDlg::JPRender()
{
	//if(!m_bActive) return;
	// º˝¿⁄ ¿ÃπÃ¡ˆ √‚∑¬ // ∆˜¡Ó∞™, ¿ÃπÃ¡ˆπ¯»£
	for( int i = 0; i < CIPHER_NUM; ++i )
	{
		if(m_stCipherNum[i].dwNumber != DEFAULT_IMAGE)
		{
			m_stNumImage[m_stCipherNum[i].dwNumber].pImage->RenderSprite( NULL, NULL, 0.0f, &m_vPos[i], 0xffffffff );
		}	
	}

	//SW050805 ¿⁄∏Æºˆ ±∏∫–¡° √ﬂ∞°. 4~9¿⁄∏Æ∏∏ √≥∏Æ
	if( 3	< m_dwMaxCipher && 
		10	> m_dwMaxCipher )
	{
		for( int i = ( m_dwMaxCipher - 1 ) / 3; i--; )
		{
			m_stNumImage[IMG_DOT].pImage->RenderSprite( NULL, NULL, 0.0f, &m_vDotPos[ i ], 0xffffffff );
		}
	}
}

void CMiniMapDlg::JPProcess()
{// JACKPOTMGR∑Œ ∫Œ≈Õ TotalMoney ∞ªΩ≈
	m_dwTotalMoney = JACKPOTMGR->GetJPTotalMoney();
	if( m_dwTotalMoney > 999999999 )
	{
		m_dwTotalMoney = 999999999;
	}
	
	SetNumImagePos();
/*
	// route for DoAni	//«œ≥™æø ∫Ø«œ¥¬ æ÷¥œ
//	if(IsNumChanged())
//	{
//		ConvertCipherNum();
//		InitForAni();
//	}
//
//	DoAni();
*/

	// route for DoSequenceAni	//Ω◊¿Ã¥¬ µÌ«— æ÷¥œ
	if(IsNumChanged())
	{
		InitForSequenceAni();
	}

	DoSequenceAni();
	
	ConvertCipherNum();
}

void CMiniMapDlg::InitForAni()
{
	//Ω«¡¶ º˝¿⁄∏¶ ¿˙¿Â«ÿµŒ∞Ì ∏µÁ º˝¿⁄ æ÷¥œ∏¶ ∫“∞° ªÛ≈¬∑Œ µ–¥Ÿ.
	for( int i = 0; i < CIPHER_NUM; ++i )
	{
		m_stCipherNum[i].dwRealCipherNum = m_stCipherNum[i].dwNumber;
	}
	// ¿¸√º æ÷¥œ Ω√¿€
	m_bIsAnimationing = TRUE;
	// æ÷¥œ ƒ´øÓ≈Õ √ ±‚»≠
	m_dwCipherCount = 0;
	// æ÷¥œ Ω√¿€ Ω√∞¢
	m_dwAniStartTime = gCurTime;
}

void CMiniMapDlg::InitForSequenceAni()
{
	if(!m_bDoSequenceAni) return;

	m_bIsAnimationing = TRUE;

	m_dwAniStartTime = gCurTime;

	m_dwTotalMoney = m_dwOldTotalMoney;// When TotalMoney Decrease // µ∑¡ŸæÓµÈ∏È ±◊≥… ¬Ô∞Ì∏∏¥Ÿ.(KES PM¥‘ ¡ˆΩ√)
}

void CMiniMapDlg::JPInit()
{
	memset(m_vPos, 0, sizeof(VECTOR2)*CIPHER_NUM);		// º˝¿⁄√¢ ¿⁄∏Æºˆ ¿ßƒ°

	m_dwTotalMoney	= 0;			// √—±›æ◊
	m_dwOldTotalMoney	= 0;
	m_dwTempMoney	= 0;

	m_dwAniStartTime	= 0;
	m_dwNumChangeTime	= 0;
	m_dwIntervalAniTime	= 0;	
	m_dwMaxCipher	= 0;
	m_dwCipherCount	= 0;
	m_bIsAnimationing	= FALSE;
	m_bDoSequenceAni	= FALSE;

	ConvertCipherNum();
	//SW050802 snake_legs
//	m_BeforeTime = 0;
}

/*	//SW050802 snake_legs
void CMiniMapDlg::SetParticlePos()
{
	for( int i = 0; i < CIPHER_NUM; ++i )
	{
		for( int j = 0; j < PARTICLE_PER_NUM; ++j )
		{
			int sign_x = rand()%2;
			sign_x > 0 ? sign_x = 1 : sign_x = -1;
			m_stPtc[i][j].vDir.x = rand()%RND_RANGE * sign_x;
			m_stPtc[i][j].vPos.x = m_vPos[i].x;
			int sign_y = rand()%2;
			sign_y > 0 ? sign_y = 1 : sign_y = -1;
			m_stPtc[i][j].vDir.y = rand()%RND_RANGE * sign_y;
			m_stPtc[i][j].vPos.y = m_vPos[i].y;
		}
	}
}
	
void CMiniMapDlg::CalcMotion()
{
	if( gCurTime - m_BeforeTime < 250 ) return;
	for( int i = 0; i < CIPHER_NUM; ++i )
	{
		for( int j = 0; j < PARTICLE_PER_NUM; ++j )
		{
			m_stPtc[i][j].vPos.x += m_stPtc[i][j].vDir.x;
			m_stPtc[i][j].vDir.y -= GRAVITY;
			m_stPtc[i][j].vPos.y += m_stPtc[i][j].vDir.y;
		}
	}

	m_BeforeTime = gCurTime;
}
*/
